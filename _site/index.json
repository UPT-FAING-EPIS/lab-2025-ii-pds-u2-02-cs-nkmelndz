{
  "CustomerApp/disenio.html": {
    "href": "CustomerApp/disenio.html",
    "title": "",
    "summary": "classDiagram class CustomerRegistration CustomerRegistration : +RegisterCustomer() Boolean class Customer Customer : +String Name Customer : +String Email Customer : +String MobileNumber Customer : +String Address Customer : +String Password Customer : +Create() Customer class DataAccessLayer DataAccessLayer : +List~Customer~ Customers DataAccessLayer : +SaveCustomer() Boolean class EmailService EmailService : +SendRegistrationEmail() Boolean class Validator Validator : +ValidateCustomer() Boolean Customer <-- DataAccessLayer"
  },
  "Notifications/disenio.html": {
    "href": "Notifications/disenio.html",
    "title": "",
    "summary": "classDiagram class AbstractMessage AbstractMessage : +SendMessage() String class EmailMessageSender EmailMessageSender : +SendMessage() String class IMessageSender IMessageSender : +SendMessage() String class LongMessage LongMessage : +SendMessage() String class ShortMessage ShortMessage : +SendMessage() String class SmsMessageSender SmsMessageSender : +SendMessage() String IMessageSender <|.. EmailMessageSender AbstractMessage <|-- LongMessage AbstractMessage <|-- ShortMessage IMessageSender <|.. SmsMessageSender"
  },
  "README.html": {
    "href": "README.html",
    "title": "SESION DE LABORATORIO N° 02: PATRONES DE DISEÑO ESTRUCTURALES",
    "summary": "SESION DE LABORATORIO N° 02: PATRONES DE DISEÑO ESTRUCTURALES Nombre: OBJETIVOS Comprender el funcionamiento de algunos patrones de diseño de software del tipo estructural. REQUERIMIENTOS Conocimientos: Conocimientos básicos de Bash (powershell). Conocimientos básicos de Contenedores (Docker). Hardware: Virtualization activada en el BIOS.. CPU SLAT-capable feature. Al menos 4GB de RAM. Software: Windows 10 64bit: Pro, Enterprise o Education (1607 Anniversary Update, Build 14393 o Superior) Docker Desktop Powershell versión 7.x Net 8 o superior Visual Studio Code CONSIDERACIONES INICIALES Clonar el repositorio mediante git para tener los recursos necesarios DESARROLLO PARTE I: Bridge Design Pattern Iniciar la aplicación Powershell o Windows Terminal en modo administrador Ejecutar el siguiente comando para crear una nueva solución dotnet new sln -o Notifications Acceder a la solución creada y ejecutar el siguiente comando para crear una nueva libreria de clases y adicionarla a la solución actual. cd Notifications dotnet new classlib -o Notifications.Domain dotnet sln add ./Notifications.Domain/Notifications.Domain.csproj Ejecutar el siguiente comando para crear un nuevo proyecto de pruebas y adicionarla a la solución actual dotnet new nunit -o Notifications.Domain.Tests dotnet sln add ./Notifications.Domain.Tests/Notifications.Domain.Tests.csproj dotnet add ./Notifications.Domain.Tests/Notifications.Domain.Tests.csproj reference ./Notifications.Domain/Notifications.Domain.csproj Iniciar Visual Studio Code (VS Code) abriendo el folder de la solución como proyecto. En el proyecto Notifications.Domain, si existe un archivo Class1.cs proceder a eliminarlo. Asimismo en el proyecto Notifications.Domain.Tests si existiese un archivo UnitTest1.cs, también proceder a eliminarlo. Primero se necesita implementar la interfaz que servirá de PUENTE entre la clase abstracta de mensajes y las posible implementaciones de envio. Por eso en VS Code, en el proyecto Notifications.Domain proceder a crear el archivo IMessageSender.cs : namespace Notifications.Domain { public interface IMessageSender { string SendMessage(string Message); } } Ahora proceder a implementar las clases concretas o implementaiones a partir de la interfaz creada, Para esto en el proyecto Notifications.Domain proceder a crear los archivos siguientes: SmsMessageSender.cs namespace Notifications.Domain { public class SmsMessageSender : IMessageSender { public string SendMessage(string Message) { return \"'\" + Message + \"' : This Message has been sent using SMS\"; } } } EmailMessageSender.cs namespace Notifications.Domain { public class EmailMessageSender : IMessageSender { public string SendMessage(string Message) { return \"'\" + Message + \"' : This Message has been sent using Email\"; } } } Seguidamente crear la clase abstracta que permitira definir los posibles tipos de mensajes por lo que en el proyecto de Notifications.Domain se debe agregar el archivo AbstractMessage.cs con el siguiente código: namespace Notifications.Domain { public abstract class AbstractMessage { protected IMessageSender _messageSender; public abstract string SendMessage(string Message); } } Sobre esta clase abstracta ahora se necesita implementar los tipos de mensajes concretos, para eso adicionar los siguientes archivos al proyecto Notifications.Domain: ShortMessage.cs namespace Notifications.Domain { public class ShortMessage: AbstractMessage { public const string LARGE_ERROR_MESSAGE = \"Unable to send the message as length > 10 characters\"; public ShortMessage(IMessageSender messageSender) { this._messageSender = messageSender; } public override string SendMessage(string Message) { if (Message.Length <= 25) return _messageSender.SendMessage(Message); else throw new ArgumentException(LARGE_ERROR_MESSAGE); } } } LongMessage.cs namespace Notifications.Domain { public class LongMessage: AbstractMessage { public LongMessage(IMessageSender messageSender) { this._messageSender = messageSender; } public override string SendMessage(string Message) { return _messageSender.SendMessage(Message); } } } Ahora proceder a implementar unas pruebas para verificar el correcto funcionamiento de la aplicación. Para esto al proyecto Notifications.Domain.Tests adicionar el archivo MessageTests.cs y agregar el siguiente código: using Notifications.Domain; using NUnit.Framework; namespace Notifications.Domain.Tests { public class MessageTests { [Test] public void GivenLongMessage_WhenSend_ThenEmailIsTriggered() { string Message = \"Este es un mensaje bien pero bien largoooooooooooooooooooooooo.\"; AbstractMessage longMessage = new LongMessage(new EmailMessageSender()); var confirm = longMessage.SendMessage(Message); Assert.IsTrue(!string.IsNullOrEmpty(confirm)); Assert.IsTrue(confirm.Contains(Message)); } [Test] public void GivenShortMessage_WhenSend_ThenSMSIsTriggered() { string Message = \"Este es un mensaje corto.\"; AbstractMessage shortMessage = new ShortMessage(new SmsMessageSender()); var confirm = shortMessage.SendMessage(Message); Assert.IsTrue(!string.IsNullOrEmpty(confirm)); Assert.IsTrue(confirm.Contains(Message)); } [Test] public void GivenLargeMessage_WhenSendinSMS_ThenOccursException() { string Message = \"Este es un mensaje largooooooooooooooooo.\"; AbstractMessage shortMessage = new ShortMessage(new SmsMessageSender()); Assert.Throws<ArgumentException>( () => shortMessage.SendMessage(Message) , ShortMessage.LARGE_ERROR_MESSAGE); } } } Ahora necesitamos comprobar las pruebas contruidas para eso abrir un terminal en VS Code (CTRL + Ñ) o vuelva al terminal anteriormente abierto, y ejecutar los comandos: dotnet test --collect:\"XPlat Code Coverage\" Si las pruebas se ejecutaron correctamente debera aparcer un resultado similar al siguiente: Passed! - Failed: 0, Passed: 3, Skipped: 0, Total: 3, Duration: 5 ms En el terminal, ejecutar el siguiente comando para generar el diagrama de clases respectivo, tener en consideración que ruta del DLL puede ser distinta según la versión de .NET tenga instalada en el equipo. dotnet tool install --global dll2mmd dll2mmd -f Notifications.Domain/bin/Debug/net8.0/Notifications.Domain.dll -o disenio.md PARTE II: Facade Design Pattern Iniciar una nueva instancia de la aplicación Powershell o Windows Terminal en modo administrador Ejecutar el siguiente comando para crear una nueva solución dotnet new sln -o CustomerApp Acceder a la solución creada y ejecutar el siguiente comando para crear una nueva libreria de clases y adicionarla a la solución actual. cd CustomerApp dotnet new classlib -o CustomerApp.Domain dotnet sln add ./CustomerApp.Domain/CustomerApp.Domain.csproj Ejecutar el siguiente comando para crear un nuevo proyecto de pruebas y adicionarla a la solución actual dotnet new nunit -o CustomerApp.Domain.Tests dotnet sln add ./CustomerApp.Domain.Tests/CustomerApp.Domain.Tests.csproj dotnet add ./CustomerApp.Domain.Tests/CustomerApp.Domain.Tests.csproj reference ./CustomerApp.Domain/CustomerApp.Domain.csproj Iniciar Visual Studio Code (VS Code) abriendo el folder de la solución como proyecto. En el proyecto CustomerApp.Domain, si existe un archivo Class1.cs proceder a eliminarlo. Asimismo en el proyecto CustomerApp.Domain.Tests si existiese un archivo UnitTest1.cs, también proceder a eliminarlo. Primero se necesita implementar la entidad Cliente, para esto crear el archivo Customer.cs en el proyecto CustomerApp.Domain con el siguiente código: namespace CustomerApp.Domain { public class Customer { public string Name { get; set; } public string Email { get; set; } public string MobileNumber { get; set; } public string Address { get; set; } public string Password { get; set; } public static Customer Create(string name, string email, string mobileNumber, string address, string password) { return new Customer() { Name = name, Email = email, MobileNumber = mobileNumber, Address = address, Password = password }; } } } Ahora se debe implementar cada una de clases correspondiente al flujo de creaciòn del cliente (validar, guardar y enviar email) para eso se deberan crear los siguientes archivos con el còdigo correspondiente: Validator.cs namespace CustomerApp.Domain { public class Validator { public bool ValidateCustomer(Customer customer) { //Need to Validate the Customer Object if (string.IsNullOrEmpty(customer.Name)) throw new ArgumentException(\"Name can't be null or empty\"); if (string.IsNullOrEmpty(customer.Email)) throw new ArgumentException(\"Email can't be null or empty\"); if (string.IsNullOrEmpty(customer.MobileNumber)) throw new ArgumentException(\"MobileNumber can't be null or empty\"); if (string.IsNullOrEmpty(customer.Address)) throw new ArgumentException(\"Address can't be null or empty\"); return true; } } } DataAccessLayer.cs namespace CustomerApp.Domain { public class DataAccessLayer { public List<Customer> Customers { get; set; } public DataAccessLayer() { Customers = new List<Customer>(); } public bool SaveCustomer(Customer customer) { Customers.Add(customer); return true; } } } EmailService.cs using System.Net; using System.Net.Mail; namespace CustomerApp.Domain { public class EmailService { public bool SendRegistrationEmail(Customer customer) { var smtpClient = new SmtpClient(\"smtp.gmail.com\") { UseDefaultCredentials = false, //Port = 587, Credentials = new NetworkCredential(customer.Email, customer.Password), EnableSsl = true, }; var mailMessage = new MailMessage { From = new MailAddress(customer.Email), Subject = \"Test mail\", Body = \"<h1>Hello</h1>\", IsBodyHtml = true, }; mailMessage.To.Add(customer.Email); //smtpClient.Send(mailMessage); return true; } } } Para probar esta implementación, crear el archivo CustomerTests.cs en el proyecto CustomerApp.Domain.Tests: using NUnit.Framework; namespace CustomerApp.Domain.Tests { public class CustomerTests { [Test] public void GivenANewCustomer_WhenRegister_ThenIsValidatedSavedEmailedSuccessfully() { //Step1: Create an Instance of Customer Class Customer customer = Customer.Create( \"Jose Cuadros\",\"p.cuadros@gmail.com\",\"1234567890\",\"Tacnamandapio\",\"str0ng.pa55\"); //Step2: Validate the Customer Validator validator = new Validator(); bool IsValid = validator.ValidateCustomer(customer); //Step3: Save the Customer Object into the database DataAccessLayer dataAccessLayer = new DataAccessLayer(); bool IsSaved = dataAccessLayer.SaveCustomer(customer); //Step4: Send the Registration Email to the Customer EmailService email = new EmailService(); bool IsEmailed = email.SendRegistrationEmail(customer); Assert.IsNotNull(customer); Assert.Greater(dataAccessLayer.Customers.Count,0); Assert.IsTrue(IsValid); Assert.IsTrue(IsSaved); Assert.IsTrue(IsEmailed); } } } Ahora necesitamos comprobar las pruebas contruidas para eso abrir un terminal en VS Code (CTRL + Ñ) o vuelva al terminal anteriormente abierto, y ejecutar el comando: dotnet test --collect:\"XPlat Code Coverage\" Si las pruebas se ejecutaron correctamente debera aparcer un resultado similar al siguiente: Total tests: 1. Passed: 1. Failed: 0. Skipped: 0 Entonces ¿cuál es problema con este diseño? Funciona.... pero el problema es que ahora existen muchos sub sistemas como Validador, Acceso a Datos y Servicio de Email y el cliente que las utilice necesita seguir la secuencia apropiada para crear y consumir los objetos de los subsistemas. Existe una posibilidad que el cliente no siga esta secuencia apropiada o que olvide incluir o utilizar alguno de estos sub sistemas. Entonces si en vez de darle acceso a los sub sistemas, se crea una sola interfaz y se le brinda acceso al cliente para realizar el registo, asi la lógica compleja se traslada a esta interfaz sencilla. Para esto se utilizará el patrón FACHADA el cual escondera toda la complejidad y brindará un solo metodo cimple de usar al cliente. Para lo cual proceder a crear el archivo CustomerRegistration.cs en el proyecto CustomerApp.Domain, con el siguiente contenido: using CustomerApp.Domain; public class CustomerRegistration { public bool RegisterCustomer(Customer customer) { //Step1: Validate the Customer Validator validator = new Validator(); bool IsValid = validator.ValidateCustomer(customer); //Step1: Save the Customer Object into the database DataAccessLayer customerDataAccessLayer = new DataAccessLayer(); bool IsSaved = customerDataAccessLayer.SaveCustomer(customer); //Step3: Send the Registration Email to the Customer EmailService email = new EmailService(); email.SendRegistrationEmail(customer); return true; } } Finalmente adciionar un nuevo método de prueba en la clase CustomerTests para comprobar el funcionamiento de la nueva clase creada: [Test] public void GivenANewCustomer_WhenRegister_ThenIsRegisteredSuccessfully() { //Step1: Create an Instance of Customer Class Customer customer = Customer.Create( \"Jose Cuadros\",\"p.cuadros@gmail.com\",\"1234567890\",\"Tacnamandapio\",\"str0ng.pa55\"); //Step2: Using Facade Class bool IsRegistered = new CustomerRegistration().RegisterCustomer(customer); Assert.IsNotNull(customer); Assert.IsTrue(IsRegistered); } Ahora necesitamos comprobar las pruebas contruidas para eso abrir un terminal en VS Code (CTRL + Ñ) o vuelva al terminal anteriormente abierto, y ejecutar el comando: dotnet test --collect:\"XPlat Code Coverage\" Si las pruebas se ejecutaron correctamente debera aparcer un resultado similar al siguiente: Passed! - Failed: 0, Passed: 2, Skipped: 0, Total: 2, Duration: 11 ms En el terminal, ejecutar el siguiente comando para generar el diagrama de clases respectivo, tener en consideración que ruta del DLL puede ser distinta según la versión de .NET tenga instalada en el equipo. dotnet tool install --global dll2mmd dll2mmd -f CustomerApp.Domain/bin/Debug/net8.0/CustomerApp.Domain.dll -o disenio.md Actividades Encargadas Completar la documentación de todas las clases y generar una automatización .github/workflows/publish_docs.yml (Github Workflow) utilizando DocFx (init, metadata y build) y publicar el site de documentación generado en un Github Page. Generar una automatización de nombre .github/workflows/package_nuget.yml (Github Workflow) que ejecute: Pruebas unitarias y reporte de pruebas automatizadas Realice el analisis con SonarCloud. Contruya un archivo .nuget a partir del proyecto Notifications.Domain y del proyecto CustomerApp.Domain y los publique como un Paquete de Github Generar una automatización de nombre .github/workflows/release_version.yml (Github Workflow) que contruya la version (release) de cada paquete y publique en Github Releases e incluya los nugets generados"
  },
  "index.html": {
    "href": "index.html",
    "title": "Documentación del Proyecto",
    "summary": "Documentación del Proyecto Bienvenido a la documentación del proyecto. Aquí encontrarás información detallada sobre los módulos y componentes de los proyectos CustomerApp y Notifications. Contenido CustomerApp Notifications Consulta los enlaces anteriores para obtener más detalles sobre cada módulo."
  }
}